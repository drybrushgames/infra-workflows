name: Provision Service (Reusable)

on:
  workflow_call:
    inputs:
      service: { type: string, required: false, description: "Service name; defaults to caller repo name" }
      type:    { type: string, required: true,  description: "node|go|python" }
      mode:    { type: string, required: false, default: "tcp", description: "tcp|socket (default tcp)" }
      repo:    { type: string, required: false, description: "Git URL; defaults to caller repo" }
      port:    { type: string, required: false, default: "8080", description: "TCP port if mode=tcp" }
      host:    { type: string, required: false, default: "vps-0b87e710.tail751d97.ts.net", description: "OVH host" }
    secrets:
      TAILSCALE_OAUTH_CLIENT_ID:
        required: true
      TAILSCALE_OAUTH_CLIENT_SECRET:
        required: true
      SVC_DB_PASSWORD:
        required: true
      DISCORD_WEBHOOK_URL:
        required: false

jobs:
  provision:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Tailscale up
        uses: tailscale/github-action@v2
        with:
          oauth-client-id:  ${{ secrets.TAILSCALE_OAUTH_CLIENT_ID }}
          oauth-secret:     ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
          tags:             tag:ci
          version:          stable

      - name: Derive inputs
        id: derive
        shell: bash
        run: |
          REPO="${{ inputs.repo }}"
          if [ -z "$REPO" ]; then REPO="https://github.com/${GITHUB_REPOSITORY}.git"; fi
          NAME="${{ inputs.service }}"
          if [ -z "$NAME" ]; then NAME="${GITHUB_REPOSITORY#*/}"; fi
          echo "repo=$REPO"   >> $GITHUB_OUTPUT
          echo "name=$NAME"   >> $GITHUB_OUTPUT
          echo "path=/opt/$NAME" >> $GITHUB_OUTPUT
          echo "type=${{ inputs.type }}" >> $GITHUB_OUTPUT
          echo "mode=${{ inputs.mode }}" >> $GITHUB_OUTPUT
          echo "port=${{ inputs.port }}" >> $GITHUB_OUTPUT
          echo "socket=/opt/$NAME/run/app.sock" >> $GITHUB_OUTPUT

      - name: Ensure tools on server
        run: |
          ssh -o StrictHostKeyChecking=no deploy@${{ inputs.host }} \
            "bash -lc 'sudo apt-get update -y >/dev/null && \
                       command -v yq >/dev/null 2>&1 || { sudo apt-get install -y wget jq >/dev/null && \
                         sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64 && sudo chmod +x /usr/local/bin/yq; }'"

      - name: Create directories
        run: |
          ssh deploy@${{ inputs.host }} "sudo mkdir -p ${{ steps.derive.outputs.path }}/run ${{ steps.derive.outputs.path }}/logs ${{ steps.derive.outputs.path }}/scripts && sudo chown -R deploy:deploy ${{ steps.derive.outputs.path }}"

      - name: Create database
        run: |
          ssh deploy@${{ inputs.host }} "sudo -u postgres createdb ${{ steps.derive.outputs.name }} || true && sudo -u postgres psql -c \"GRANT ALL PRIVILEGES ON DATABASE \\\"${{ steps.derive.outputs.name }}\\\" TO svc;\" || true"

      - name: Create .env file
        run: |
          ssh deploy@${{ inputs.host }} "test -f ${{ steps.derive.outputs.path }}/.env || (echo 'DATABASE_URL=postgres://svc:${{ secrets.SVC_DB_PASSWORD }}@localhost:5432/${{ steps.derive.outputs.name }}?sslmode=disable
          NODE_ENV=production
          PORT=${{ steps.derive.outputs.port }}' | sudo tee ${{ steps.derive.outputs.path }}/.env && sudo chown deploy:deploy ${{ steps.derive.outputs.path }}/.env && sudo chmod 600 ${{ steps.derive.outputs.path }}/.env)"

      - name: Create deploy script
        run: |
          cat > deploy_script.sh << 'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          SERVICE="${{ steps.derive.outputs.name }}"
          ROOT="${{ steps.derive.outputs.path }}"
          REPO="${{ steps.derive.outputs.repo }}"
          
          if [ ! -d "$ROOT/.git" ]; then
            git clone "$REPO" "$ROOT"
          fi
          
          git -C "$ROOT" fetch --all
          git -C "$ROOT" reset --hard origin/main
          
          make -C "$ROOT" build || true
          
          if [ -f "$ROOT/package.json" ]; then
            cd "$ROOT"
            command -v pnpm >/dev/null 2>&1 && pnpm i --prod || npm ci --omit=dev || npm i --omit=dev
          fi
          
          sudo /usr/bin/systemctl restart ${SERVICE}.service || true
          echo "Deploy OK for $SERVICE"
          EOF
          
          scp deploy_script.sh deploy@${{ inputs.host }}:${{ steps.derive.outputs.path }}/scripts/deploy.sh
          ssh deploy@${{ inputs.host }} "sudo chown deploy:deploy ${{ steps.derive.outputs.path }}/scripts/deploy.sh && sudo chmod +x ${{ steps.derive.outputs.path }}/scripts/deploy.sh"
          rm deploy_script.sh

      - name: Install systemd unit (tcp or socket)
        run: |
          ssh deploy@${{ inputs.host }} "bash -lc '
            set -euo pipefail
            NAME=\"${{ steps.derive.outputs.name }}\"
            PATHDIR=\"${{ steps.derive.outputs.path }}\"
            MODE=\"${{ steps.derive.outputs.mode }}\"
            TYPE=\"${{ steps.derive.outputs.type }}\"
            SOCKET=\"${{ steps.derive.outputs.socket }}\"
            PORT=\"${{ steps.derive.outputs.port }}\"

            case \"$TYPE\" in
              node)
                if [ \"$MODE\" = \"socket\" ]; then
                  EXEC=\"/usr/bin/bash -lc \\\"mkdir -p ${PATHDIR}/run && node ${PATHDIR}/backend/server.js --socket ${SOCKET}\\\"\"
                else
                  EXEC=\"/usr/bin/bash -lc \\\"PORT=\\\${PORT:-$PORT} npm --prefix ${PATHDIR} start\\\"\"
                fi
                ;;
              go)
                if [ \"$MODE\" = \"socket\" ]; then
                  EXEC=\"/usr/bin/bash -lc \\\"mkdir -p ${PATHDIR}/run && ${PATHDIR}/bin/server --socket ${SOCKET}\\\"\"
                else
                  EXEC=\"/usr/bin/bash -lc \\\"PORT=\\\${PORT:-$PORT} ${PATHDIR}/bin/server\\\"\"
                fi
                ;;
              python)
                if [ \"$MODE\" = \"socket\" ]; then
                  EXEC=\"/usr/bin/bash -lc \\\"mkdir -p ${PATHDIR}/run && uvicorn app:app --uds ${SOCKET}\\\"\"
                else
                  EXEC=\"/usr/bin/bash -lc \\\"PORT=\\\${PORT:-$PORT} uvicorn app:app --host 0.0.0.0 --port \\$PORT\\\"\"
                fi
                ;;
              *) echo Unknown type; exit 1;;
            esac

            UNIT=\"/etc/systemd/system/${NAME}.service\"
            sudo tee \"$UNIT\" >/dev/null <<EOF
[Unit]
Description=$NAME
After=network.target

[Service]
User=deploy
WorkingDirectory=${PATHDIR}
EnvironmentFile=${PATHDIR}/.env
ExecStart=${EXEC}
Restart=always

[Install]
WantedBy=multi-user.target
EOF

            sudo /usr/bin/systemctl daemon-reload
            sudo /usr/bin/systemctl enable --now ${NAME}.service || true
          '"

      - name: (socket mode only) Render simple Caddyfile and reload
        if: inputs.mode == 'socket'
        run: |
          ssh deploy@${{ inputs.host }} "bash -lc '
            NAME=\"${{ steps.derive.outputs.name }}\"
            SOCKET=\"${{ steps.derive.outputs.socket }}\"
            # Minimal per-service caddy fragment
            sudo tee /etc/caddy/Caddyfile >/dev/null <<ECF
# generated
${NAME}.local {
  reverse_proxy unix//${SOCKET}
}
ECF
            sudo /usr/bin/caddy reload
          '"